// Generated by LiveScript 1.4.0
(function(){
  var cli, _, median, Main, FindExponent, Public;
  cli = require("cli-color");
  _ = require("prelude-ls");
  median = require("median");
  Main = {};
  Main.DocString = "----------------------------------------------------------------------------------\n\nMatrixDisplay is a tiny module to succiently view 2D matrices on the terminal. It comes with 2 functions - Init and PrintMat. \n \nPass your 2D matrix to PrintMat to print the matrix on the terminal.\n\nInit allows you to customize the printing - you can control two variables by passing their values using a JSON.\n\n1# MaxSigFig - For Significant Figures. \n2# Blanks    - Spacing between columns. \n\nThe function PrintMat also factors out the most common exponent so you get to see the most relevant values - while saving space. \n\n---------------------------------------------------------------------------------- ";
  Main.MaxSigFig = 1;
  Main.Blanks = 0;
  Main.Init = function(Json){
    var Keys, Values;
    Json == null && (Json = {
      MaxSigFig: 3,
      Blanks: 0
    });
    for (Keys in Json) {
      Values = Json[Keys];
      if (!(typeof Values === "number")) {
        console.error(cli.redBright("Error: ") + cli.greenBright(Keys) + cli.red(" should be a numerical value"));
      } else {
        if (!(Values === undefined)) {
          this[Keys] = Values;
        }
      }
    }
  };
  Main.CleanMat = function(Mat){
    var SF, I, Iₙ, K, Elem, Kₙ, CurrentElem;
    SF = Main.MaxSigFig;
    I = 0;
    Iₙ = Mat.length;
    while (I < Iₙ) {
      K = 0;
      Elem = Mat[I];
      Kₙ = Elem.length;
      while (K < Kₙ) {
        CurrentElem = Elem[K];
        if (typeof CurrentElem === "string") {
          CurrentElem = parseFloat(CurrentElem);
        }
        Elem[K] = parseFloat(CurrentElem.toPrecision(SF));
        K += 1;
      }
      I += 1;
    }
    return Mat;
  };
  Main.ExpoAnalysis = function(Matrix){
    var dLoop, ValAnPower, ExpoMat, MedianBase, Output, abs, pow, SF, I, Iₙ, Elem, Row, K, Kₙ, X, ColPower, DPValue, Input;
    dLoop = function(f){
      return _.map(_.map(f));
    };
    ValAnPower = dLoop(FindExponent)(
    Matrix);
    ExpoMat = dLoop(function(x){
      return x[1];
    })(
    ValAnPower);
    MedianBase = median(
    _.flatten(
    ExpoMat));
    Output = [];
    abs = Math.abs, pow = Math.pow;
    SF = this.MaxSigFig;
    I = 0;
    Iₙ = ExpoMat.length;
    while (I < Iₙ) {
      Elem = ValAnPower[I];
      Row = [];
      K = 0;
      Kₙ = Elem.length;
      while (K < Kₙ) {
        X = Elem[K];
        ColPower = X[1] - MedianBase;
        DPValue = parseFloat((X[0] * pow(10, ColPower)).toPrecision(SF));
        if (abs(ColPower) > SF) {
          Input = fn$(
          DPValue);
        } else {
          Input = DPValue.toString();
        }
        Row.push(Input);
        K += 1;
      }
      Output.push(Row);
      I += 1;
    }
    return {
      DisplayMat: Output,
      Base: MedianBase
    };
    function fn$(it){
      return it.toExponential();
    }
  };
  FindExponent = function(Num){
    var OutCome;
    OutCome = Num.toExponential().match(/(.*)e(.*)/);
    return _.map(parseInt, [OutCome[1], OutCome[2]]);
  };
  Main.FindMaxColumnLength = function(Mat){
    var ColumnLen, Iₙ, I, MaxRowSize, Elem, Kₙ, K, Len;
    ColumnLen = [];
    Iₙ = Mat.length;
    I = 0;
    MaxRowSize = 0;
    while (I < Iₙ) {
      Elem = Mat[I];
      Kₙ = Elem.length;
      K = 0;
      while (K < Kₙ) {
        Len = fn$(
        Elem[K]);
        if (ColumnLen[K] === undefined) {
          ColumnLen[K] = 0;
        }
        if (ColumnLen[K] < Len) {
          ColumnLen[K] = Len;
        }
        K += 1;
        if (MaxRowSize < Kₙ) {
          MaxRowSize = Kₙ;
        }
      }
      I += 1;
    }
    return {
      "ColumnLen": ColumnLen,
      "MaxRowSize": MaxRowSize
    };
    function fn$(it){
      return it.length;
    }
  };
  Main.PrintMat = function(Mat){
    var ref$, DisplayMat, Base, ColumnLen, MaxRowSize, stdout, Iₙ, TerminalHorSize, MinSizeForColon, I, CursorPos, K, Elem, Kₙ, ColMaxSize, CurrentNumber, SizeOfStringToBeDisplayed, BlankSize, J, Spaces, EndLine;
    if (!(Array.isArray(Mat[0]) === true)) {
      console.log(Mat);
      return;
    }
    ref$ = this.ExpoAnalysis(
    this.CleanMat(
    Mat)), DisplayMat = ref$.DisplayMat, Base = ref$.Base;
    ref$ = this.FindMaxColumnLength(
    DisplayMat), ColumnLen = ref$.ColumnLen, MaxRowSize = ref$.MaxRowSize;
    stdout = process.stdout;
    Iₙ = DisplayMat.length;
    TerminalHorSize = stdout.columns;
    MinSizeForColon = TerminalHorSize * 0.75;
    I = 0;
    while (I < Iₙ) {
      CursorPos = 0;
      K = 0;
      Elem = DisplayMat[I];
      Kₙ = Elem.length;
      while (K < MaxRowSize) {
        ColMaxSize = ColumnLen[K];
        if (K < Kₙ) {
          CurrentNumber = Elem[K];
          SizeOfStringToBeDisplayed = CurrentNumber.length;
          BlankSize = ColMaxSize - SizeOfStringToBeDisplayed;
        } else {
          CurrentNumber = "-";
          BlankSize = ColMaxSize - 1;
        }
        BlankSize += this.Blanks;
        J = 0;
        Spaces = "";
        while (J <= BlankSize) {
          Spaces += " ";
          J += 1;
        }
        CursorPos += ColMaxSize + BlankSize + 1;
        stdout.write(Spaces + CurrentNumber);
        K += 1;
      }
      if (CursorPos % TerminalHorSize > MinSizeForColon) {
        EndLine = "; \n";
      } else {
        EndLine = "\n";
      }
      stdout.write(EndLine);
      I += 1;
    }
    stdout.write(
    (function(it){
      return "*" + it;
    })(
    function(it){
      return it.toExponential();
    }(
    Math.pow(10, Base))));
  };
  Public = {};
  Public.DocString = Main.DocString;
  Public.Init = Main.Init.bind(Main);
  Public.PrintMat = Main.PrintMat.bind(Main);
  module.exports = Public;
}).call(this);
